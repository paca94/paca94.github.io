<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://jihwankim.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jihwankim.github.io/" rel="alternate" type="text/html" /><updated>2021-06-18T00:24:16+09:00</updated><id>https://jihwankim.github.io/feed.xml</id><title type="html">JihwanKim Develop Blog</title><subtitle>백엔드 개발자이며, 취미로 플러터, 유니티를 만지는 개발자</subtitle><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><entry><title type="html">FCM을 사용하면서 발생한 문제들</title><link href="https://jihwankim.github.io/develop/FCM-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%9C-%EB%AC%B8%EC%A0%9C%EB%93%A4/" rel="alternate" type="text/html" title="FCM을 사용하면서 발생한 문제들" /><published>2021-06-17T00:00:00+09:00</published><updated>2021-06-17T22:06:00+09:00</updated><id>https://jihwankim.github.io/develop/FCM-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%9C-%EB%AC%B8%EC%A0%9C%EB%93%A4</id><content type="html" xml:base="https://jihwankim.github.io/develop/FCM-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%9C-%EB%AC%B8%EC%A0%9C%EB%93%A4/">&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;FCM을 사용하면서 겪은 문제와 문제를 해결했던 방법.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;FCM 을 사용하면서 겪은 문제와 해당 문제들을 어떻게 해결하였고, 앞으로 어떤 방식으로 사용을 해야할 지에 대해 고민했던 것들에 대한 글이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;어디까지나 필자 개인의 경험을 기반으로 한 글이다.&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-fcm-push-topic_rate_exceeded-error&quot;&gt;1. FCM Push TOPIC_RATE_EXCEEDED error&lt;/h1&gt;
&lt;p&gt;하나의 토픽에 많은 양의 데이터를 빠르게 전송하면, 해당 에러가 발생하며, 푸시를 더이상 할 수 없게 된다.&lt;/p&gt;

&lt;p&gt;해당 에러의 발생 사유는 아래와 같다.&lt;br /&gt;
&lt;strong&gt;특정 주제의 구독자에게 전달되는 메시지 비율이 너무 높습니다. 이 주제로 보내는 메시지 수를 줄이세요. 바로 다시 보내도록 시도해서는 안 됩니다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;단위토픽에 대해 전송되는 메세지의 개수를 줄여야 한다라는 문제가 생겼다.&lt;br /&gt;
해당 문제를 해결한 방법은 아래와 같다.&lt;/p&gt;

&lt;p&gt;해결당시 사용언어는 Erlang이며, Erlang의 특징은 분산처리 및 경량프로세스이며, 분산처리를 언어자체에서 지원을 해준다는 장점이 있다.&lt;br /&gt;
따라서, 서버를 여러대 올려놨을때, 조금만 처리를 하게되면, 각 노드간 통신을 하게끔 하는 것은 매우매우 쉬운 일이다.&lt;br /&gt;
Erlang에 보면 gen_server를 실행시킬 때, global로 등록할 것인지, local에 등록할 것인지 옵션을 통해 지정해 줄 수 있다.&lt;br /&gt;
global로 실행시킨 다면, 통신하고 있는 노드들 중에서 동일한 이름의 gen_server는 오직 하나의 프로세스만 실행이 가능하다.&lt;br /&gt;
해당 특성을 이용하여, push해야하는 topic 이름으로 gen_server를 실행시켜, 푸시 요청이 올 경우, 0.25초 마다 한번씩만 보내도록 하였다.&lt;br /&gt;
해당 개수는 문서 상에서 FCM의 클라이언트 수신 가능한 최대 개수가 분당 240개. 시간당 5000개까지 제한하고 있다는 점에서 가져온 것이고, 실제로 토픽에 0.25초당 한번씩 보내게 되는 경우는 없을거라고 생각한다.&lt;/p&gt;

&lt;p&gt;기존에 작업했던 서버의 경우 주된 푸시 방법이 FCM이다. 또한, 데이터를 동기화하는데 이용하였다.&lt;br /&gt;
하지만, 지금 생각해 보면, 메인 푸시를 FCM을 사용하는 것이 당시에는 최선의 방법이었을 수 있지만(필자가 1년도 안되었을 때, 다른분들이 결정하셨었다.), 지금은 아니라 생각한다. 주된 데이터를 동기화하는 방법으로는 맞지 않다고 생각한다.&lt;br /&gt;
애초에 토픽에 0.25초당 하나씩 보내는 상황 자체를 만들지 않도록 구성하는 것이 옳은 방향이라 생각한다. &lt;br /&gt;
따라서, 추후 FCM을 사용한다면, 어디까지나, 알람 용도로 사용해야 하지, 많은 데이터를 전송하는 용도로 사용하는 것은 경험상 좋진 않다고 생각한다. 데이터 전송이 많다면, 백그라운드는 굳이 돌리지 말고, 앱이 포그라운드일때, MQTT같은 것을 사용해서 데이터를 푸시받는게 옳은 방향이라 생각된다.&lt;/p&gt;

&lt;p&gt;만약, 이후 데이터를 FCM으로 받게 되는 일이 있다면, 도저히 시간이 나지 않는 상황이나, 데이터 전송이 자주 일어나지 않게 되는 경우에만 사용하게 될 것 같다.&lt;/p&gt;

&lt;p&gt;참고 링크&lt;br /&gt;
&lt;a href=&quot;https://firebase.google.com/docs/cloud-messaging/concept-options#device_throttling&quot;&gt;단일 기기에 대한 최대 메시지 속도&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://firebase.google.com/docs/cloud-messaging/send-message?hl=ko#admin&quot;&gt;FCM 에러 목록&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-동시에-여러명의-유저들에-대해-선별하여-알람보내기&quot;&gt;2. 동시에 여러명의 유저들에 대해 선별하여 알람보내기&lt;/h1&gt;

&lt;p&gt;이전에 개발헀던 서비스의 서버에 보면, 여러명의 유저가 하나의 토픽을 함께 구독하고 있는 상황이 많고, 해당 토픽에 대해 공통적으로 알람을 보내야하는 경우가 있다.&lt;br /&gt;
하지만, 유저에 따라, 알람을 켜놓거나 꺼놓을 수 있으므로, 해당 토픽으로 한번에 알람을 푸시하게 되면, 원하지 않는 유저가 알람을 받게 된다.&lt;br /&gt;
따라서, 해당 부분에 대해서는 2가지 방법을 생각했었다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;유저의 토큰을 서버에 저장하여, 알람을 끄지 않은 유저들에 대해서만 알람 전송&lt;/li&gt;
  &lt;li&gt;데이터 푸시토픽과 알람토픽의 분리&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;당시 선택한 방법은 1번이었다.&lt;br /&gt;
알람을 끄지 않은 유저에 대해서 선별은 데이터베이스에 해당 유저의 알람 onoff 여부를 조회하여 확인하였다.&lt;br /&gt;
그리고 푸시는 multicast 방법을 사용하면, 동시에 최대 1000개 토큰에 대해서 동시에 보낼 수 있어서, 해당 방법을 사용하였다.&lt;br /&gt;
해당 방법을 사용함으로써, 알람정보를 가지고 있는 DB에 대해 의존성이 생겼지만, 그부분은 어쩔 수 없는 부분이라 생각된다.&lt;/p&gt;

&lt;p&gt;만약, 2번째 방법을 사용한다고 했을 때, 구독할 수 있는 토픽의 개수가 최악의 경우, 절반 정도 밖에 안되게 된다. (FCM 최대 구독가능 개수가 약 2000개 였던것으로 기억한다.)&lt;br /&gt;
따라서, 당시에 떠올렸었어도, 1번 방법으로 진행했을거라 생각한다.&lt;/p&gt;

&lt;h1 id=&quot;3-topic은-구독중인데-해당-유저에게-fcm을-전송할-경우-데이터가-누락되는-문제&quot;&gt;3. Topic은 구독중인데, 해당 유저에게 FCM을 전송할 경우, 데이터가 누락되는 문제&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;아직 해결하지 못한 문제입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;어느날, 특정 토픽에 대해 알람 및 데이터 푸시를 받지 못하는 현상이 발생하였다.&lt;br /&gt;
혹시, 해당 토픽을 FCM단에서 구독해제 되었거나, FCM TOKEN이 만료되었을 수 있겠다는 가능성을 열어두고, 테스트를 진행하였다.&lt;br /&gt;
첫번째로 해당 토큰이 만료되었는지, 혹시 정상적으로 작동하지 않는지에 대해 테스트하였다.&lt;br /&gt;
데이터, 데이터/알람, 알람 순으로 해당 토큰으로 메세지를 전송해보았는데, 클라이언트에서 모두 정상적으로 수신에 성공하였다.&lt;br /&gt;
그 뒤, 대상 토픽에 대해 정상적으로 구독하고 있는지 확인하였고, 해당 토픽은 정상적으로 구독이 되어있는 상태였다.&lt;br /&gt;
이후, 다시 데이터, 데이터/알람, 알람 순으로 해당 토픽으로 메세지를 전송해봤는데, 클라이언트에서 정상적으로 수신하지 못하였다.&lt;br /&gt;
일단, 당시 클라이언트는 AOS였고, AOS에서는 알람을 백그라운드에서 직접 생성을 한다.  알람이 생성되어야 할 동작이 이루어졌음에도 불구하고, 알람을 노출하지 않았고, 앱을 껏다 켰을 때 동기화 API에 의해 데이터를 가져오고 있었다.&lt;br /&gt;
그리고 만약, FCM단에서 알람을 전송한다면, 그 어떤 처리도 없기 떄문에 알람이 고스란히 노출된다. 하지만, 알람은 도착하지를 않았다.&lt;br /&gt;
따라서, 해당 토픽에 대해 다른 클라이언트를 구독하였고, 다시 테스트 해본 결과 다른 클라이언트는 정상적으로 데이터 및 알람을 모두 받는데, 해당 클라이언트만 여전히 못받고 있었다.&lt;br /&gt;
따라서, 서버단에서 재구독 하였더니, 정상적으로 수신되기 시작하였다.&lt;/p&gt;

&lt;p&gt;이후에, 데이터만 포함된 FCM 메세지를 받지 못하는 버그도 발생하였었다.&lt;br /&gt;
해당 문제 또한 재구독으로 해결하였다.&lt;/p&gt;

&lt;p&gt;위 문제에 대해 고민을 해보았고, 해당 문제에 대한 해결법은 해당 토큰으로 직접 보내는 방법이라고 생각을 하고 있다. &lt;br /&gt;
토픽에 대해서는 이유없이 데이터 수신이 되질 않으니, 해당 상황이 발생하였을 때 정상동작하였던 토큰을 통한 발송이 당장 떠오르는 방법이다.&lt;/p&gt;

&lt;h1 id=&quot;4-http--httpv1-api로-이전하지-않은-이유&quot;&gt;4. HTTP &amp;gt; HTTPv1 API로 이전하지 않은 이유&lt;/h1&gt;
&lt;p&gt;해당 방법으로의 이전을 고민하던 당시에, 개발하던 서버에서는 AOS/IOS를 각각 따로 FCM PUSH를 하였다.&lt;br /&gt;
즉, 개선된 버전에서는 1번만 보내도 될 것을 기존 버전에서는 2번보내고 있으므로, 해당 횟수를 줄일 수 있다면, 줄이는 것이 맞는 방법이라 생각하였다.&lt;br /&gt;
따라서, HTTP API &amp;gt; HTTP v1 API 로 이전을 시도해보았다.&lt;/p&gt;

&lt;p&gt;기존 버전의 경우, FCM ServerKey를 이용하여 고정된 키값을 Header에 넣어서 전송요청하는 방법을 사용하였는데, v1의 경우, Access Token을 발급하여, 메세지를 전송한다.&lt;br /&gt;
그리고, IOS/AOS/WEB 등에 대해 한번에 푸시할 수 있도록 개선되었다.&lt;/p&gt;

&lt;p&gt;하지만, 복병은 의외의 곳에서 나타났다.&lt;br /&gt;
AOS에서 데이터를 FCM 푸시를 수신하지 못하는 것이다.&lt;br /&gt;
뭔가 이상함을 느끼고 여러가지 테스트를 진행해 보았고, FCM Data Push가 도착할 때마다 토스트 메세지를 띄워주도록 변경한 클라이언트를 AOS/IOS에 요청하여 받아 테스트해봤는데, AOS에서는 메세지가 도착하질 않았다.&lt;br /&gt;
기존 버전으로 테스트 할 때는 잘 되던 것이 v1에서는 되질 않아서, 내가 잘못보냈나 하면서 바꿔가면서 테스트해봐도, 여전히 수신을 못하고 있었다. ( Firebase 서버에서 못보내는건지, Android에서 못받는건지 모르겠다. )&lt;/p&gt;

&lt;p&gt;위의 이유 때문에 이전은 하지 않게 되었다.&lt;br /&gt;
만약, 됐었어도 HTTP &amp;gt; HTTPv1 으로 변경하지 않은 추가적인 이유는 아래와 같다.&lt;br /&gt;
multicast 방법을 지원하지 않는다.
만약, Google에서 인증 서버에 문제가 생겨서 AccessToken을 재발급받지 못하면, 장애가 난 시간만큼 클라이언트에 푸시가 전송되지 않게 된다.&lt;/p&gt;

&lt;h1 id=&quot;5-http-api에서-aosios-푸시는-함께--따로-&quot;&gt;5. HTTP API에서 AOS/IOS 푸시는 함께 ? 따로 ?&lt;/h1&gt;
&lt;p&gt;과거에는 서비스의 서버에서 AOS/IOS에 대해 푸시를 따로 전송하였다.&lt;br /&gt;
그렇게 전송하는 이유는 이미 서비스 서버를 본격적으로 개발하기 시작했을 때는 이미 그런 상황이라 잘 모른다.&lt;br /&gt;
하지만, 위 4번에 해당하는 작업을 못하게 되면서, 그냥 IOS/AOS에 대해 같은데이터를 넣고 한번에 푸시를 보내니, 둘 모두 데이터를 정상적으로 수신하였다.&lt;br /&gt;
물론, 각각(AOS/IOS)의 동일한 키값에 대해 서로 다르게 받고 있는 데이터를 사용하고 있다면, 따로 전송하는 것이 맞겠지만, 개발하던 서비스에서는 그렇지 않기 때문에, 문제가 없다 판단되었다.&lt;br /&gt;
만약, 동일한 키값에 대해 서로 다르게 받아야 한다고 하면, 그때가서 개선하면 될 문제라고 생각한다.&lt;/p&gt;</content><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><category term="Develop" /><category term="FCM" /><summary type="html">FCM을 사용하면서 겪은 문제와 문제를 해결했던 방법.</summary></entry><entry><title type="html">Redis 장애</title><link href="https://jihwankim.github.io/moigo/Redis-%EC%9E%A5%EC%95%A0/" rel="alternate" type="text/html" title="Redis 장애" /><published>2021-04-18T00:00:00+09:00</published><updated>2021-04-17T22:06:00+09:00</updated><id>https://jihwankim.github.io/moigo/Redis-%EC%9E%A5%EC%95%A0</id><content type="html" xml:base="https://jihwankim.github.io/moigo/Redis-%EC%9E%A5%EC%95%A0/">&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;Redis 장애 대응&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;14일 오후 2시 36분 ~ 38분 사이에 서버에 장애가 발생했다.&lt;br /&gt;
장애 포인트는 AWS Elasticache Redis였고, 36분부터 문제가 생겨 38분에 복구되었다.&lt;br /&gt;
장애가 발생한 이유는 무엇이고, 어떻게 개선할 것인지에 대해 생각했던 것을 기록하는 글이다.&lt;/p&gt;

&lt;h1 id=&quot;장애가-2분이나-유지된-이유&quot;&gt;장애가 2분이나 유지된 이유&lt;/h1&gt;
&lt;p&gt;Redis 서비스에서 Primary 1대 Replica 1대를 사용하고 있는데, FailOver 설정을 해두지 않아서, Replica가 자동으로 Primary로 승격되지 않아 장애가 유지되었다. 즉, 장애 복구시간동안, Redis에 대한 요청이 모두 실패하여, 엮여있는 부분에서 장애가 발생하였다.&lt;/p&gt;

&lt;h1 id=&quot;장애-발생에-따라-문제가-된-부분&quot;&gt;장애 발생에 따라 문제가 된 부분&lt;/h1&gt;
&lt;p&gt;서버에서 세션정보를 저장하는 DB로 Redis를 사용하고 있는데, 유저가 API를 요청하면, 해당 세션이 유효한지 여부를 검증할 수 없는 문제가 발생하였다.&lt;/p&gt;

&lt;h1 id=&quot;추후-장애-발생을-방지하기-위해-어떻게-개선할-것인가&quot;&gt;추후, 장애 발생을 방지하기 위해 어떻게 개선할 것인가&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;Redis FailOver: true 설정 ( 기존에는 false로 설정되어있었음. )&lt;/li&gt;
  &lt;li&gt;Redis Version 5.0.4 -&amp;gt; 5.0.6 으로 업그레이드&lt;/li&gt;
  &lt;li&gt;MultiAZ 설정 ( 기존에는 false로 설정되어 있었음. )&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;추가적인-개선&quot;&gt;추가적인 개선&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;Redis의 Read Replica에 대해서 요청하지 않고 있는데, 읽을 때, Read Replica의 EndPoint로 요청하도록 개선&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;개선-근거&quot;&gt;개선 근거&lt;/h1&gt;
&lt;h2 id=&quot;redis-failover-true-설정&quot;&gt;Redis FailOver true 설정&lt;/h2&gt;
&lt;p&gt;해당 설정이 되어 있었으면, replica가 자동으로 primary로 승격되어 장애 시간이 2분이나 되지 않았을 것이다. 하지만, false로 되어 있었기 때문에, primary가 복구될 때 까지 계속 장애가 유지되었다.&lt;/p&gt;

&lt;h2 id=&quot;redis-version-504---506-으로-업그레이드&quot;&gt;Redis Version 5.0.4 -&amp;gt; 5.0.6 으로 업그레이드&lt;/h2&gt;
&lt;p&gt;아래의 문서를 근거로 버전을 업그레이드 할 예정이다.&lt;br /&gt;
만약, 문제가 생겨서 Replica가 Primary로 승격된다고 할 때, 읽기 쓰기 모두 장애는 발생하지 않는 방법이 있다면 해당 방법을 사용하는 것이 맞다 생각한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AWS 문서 발취&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ElastiCache for Redis 클러스터의 경우, 클러스터에서 들어오는 쓰기 요청을 처리하는 중에 계획된 노드 교체가 완료됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;다중 AZ가 활성화되어 5.0.5 이상 엔진에서 실행 중인 Redis 클러스터 모드 비활성화 클러스터의 경우, 클러스터에서 들어오는 쓰기 요청을 처리하는 중에 계획된 노드 교체가 완료됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;다중 AZ가 활성화되어 5.0.4 이하 엔진에서 실행 중인 Redis Cluster 모드 비활성화 클러스터의 경우, DNS 업데이트와 관련하여 짧은 쓰기 중단이 발생할 수 있습니다. 이 중단은 최대 몇 초가 걸릴 수 있습니다. 이 프로세스는 다중 AZ를 활성화하지 않은 경우 발생하는 새 기본 노드를 다시 생성하고 프로비저닝하는 것보다 훨씬 빠릅니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이후, 업데이트 내역을 살펴보니, 바로 올려도 문제는 없을것 같긴 한데, 테스트정도는 해보는게 맞다고 생각한다.&lt;br /&gt;
따라서, 개발서버용 Redis를 미리 5.0.6 으로 올려서 테스트 해보고 업데이트할 예정이다.&lt;/p&gt;

&lt;h2 id=&quot;multiaz-설정&quot;&gt;MultiAZ 설정&lt;/h2&gt;
&lt;p&gt;만약, 특정 리전에서 장애가 발생할 경우, 해당 리전에 primary와 replica가 함께 떠있다면, 그것은 곧 장애로 이어진다.&lt;br /&gt;
설정을 true로 변경하게 되면, 두개 이상의 리전에서 동시에 문제가 발생하지 않는다면, 서비스는 문제없이 유지될 것이다.&lt;/p&gt;

&lt;h2 id=&quot;redis-read-replica-end-point-사용&quot;&gt;Redis Read Replica End Point 사용&lt;/h2&gt;
&lt;p&gt;해당 부분은 기존에 사용하고 있지 않아서, 사용하려고 한다.&lt;br /&gt;
코드 상에서 Read라면, Read EndPoint로 요청할 것이고, Write라면, Primary EndPoint에 요청하게끔 개선할 예정이다.&lt;/p&gt;

&lt;h3 id=&quot;참고링크&quot;&gt;참고링크&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonElastiCache/latest/red-ug/AutoFailover.html#auto-failover-test&quot;&gt;AWS - FailOver&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonElastiCache/latest/red-ug/Endpoints.html&quot;&gt;AWS - EndPoints&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/BestPractices.html&quot;&gt;AWS - BestPractice&lt;/a&gt;&lt;/p&gt;</content><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><category term="MoiGo" /><category term="MoiGo, Erlang, AWS, Redis" /><summary type="html">Redis 장애 대응</summary></entry><entry><title type="html">Auth와 User 분리</title><link href="https://jihwankim.github.io/thinking/Auth%EC%99%80-User-%EB%B6%84%EB%A6%AC/" rel="alternate" type="text/html" title="Auth와 User 분리" /><published>2021-04-15T00:00:00+09:00</published><updated>2021-04-10T22:06:00+09:00</updated><id>https://jihwankim.github.io/thinking/Auth%EC%99%80-User-%EB%B6%84%EB%A6%AC</id><content type="html" xml:base="https://jihwankim.github.io/thinking/Auth%EC%99%80-User-%EB%B6%84%EB%A6%AC/">&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;하나의 유저 계정에 여러 로그인 방법 추가 설계 고민&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;요즘은 OAuth2를 이용하여 회원가입/로그인하는 서비스들이 매우 많아졌다.&lt;br /&gt;
해당 방법으로 로그인을 하다 보면, 동일한 계정에 대해 구글계정으로 로그인 등 여러가지 추가 로그인 방법이 있으면 좋겠다고 생각이 들 때가 있고, 기존에 사용하던 연동된 계정을 사용하지 않게 되는 경우도 발생한다.&lt;br /&gt;
따라서, 하나의 유저 계정에 여러개의 인증 방법으로 로그인 할 수 있는 방법에 대해 고민해보았고, 어떻게 해야할 지에 대해 기록한다.&lt;/p&gt;

&lt;p&gt;내가 지금까지 만들었던 DB의 대부분은 유저정보가 곧 로그인 정보와 동일하였다.&lt;br /&gt;
만약, 로그인을 이메일(아이디)/비밀번호로 사용하다가 OAuth2와 같은 로그인 방법이 추가되면, 테이블 구조와 코드가 더러워졌었다.&lt;br /&gt;
하지만, 해당 방법 말고 유저 테이블과 로그인에 필요한 인증 테이블을 다르게 가지고 간다면, 해당 문제가 발생하지 않겠다라고 생각이 들었다.&lt;/p&gt;

&lt;p&gt;해당 방법은 이전에 회사에서 퇴사하신 분과 토이프로젝트 작업을 할 때, 고민하다가 적용하였었다.&lt;br /&gt;
테이블 구조는 아래와 같이 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/image/auth_user_seperate/table_structure.png&quot; alt=&quot;table_structure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 이미지는 대략적으로 이런식으로 구현할 거라는 것만 그렸다.&lt;br /&gt;
만약, 제공자가 구글인 인증방법이 추가된다면, 테이블을 하나 추가 시키면 된다.&lt;br /&gt;
그리고 로그인 시, 입력되는 type에 따라, 인증방법을 달리하면 된다.&lt;/p&gt;

&lt;p&gt;만약, 회원가입/로그인/인증코드 추가 Erlang 코드상에서 나타낸다면, 아래와 같은 코드가 나올 것이다.&lt;br /&gt;
단, 예제를 위해 작성 하였고, 에러에 대한 대비 코드는 추가하지 않았다. 실제 코드를 실행해보지 않았다.&lt;br /&gt;
실제로 작업한다면, 함수합성을 사용할 것이다.&lt;/p&gt;
&lt;h3 id=&quot;autherl&quot;&gt;auth.erl&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Erlang&quot;&gt;  ...
  -export_all().

  -spec sign_up(bitstring(), types:auth_type(), map()) -&amp;gt; 
    {ok, map()} 
    | {error, already_exist_auth_for_email}
    | {error, already_use_email}.
  sign_up(Name, Type, AuthData)-&amp;gt;
    {ok, UserInfo} = model_user:insert(Name),
    {ok, AuthModule} = auth_plugin_utils:type_to_auth_module(Type),

    {ok, _} = AuthModule:new(UserInfo, AuthData),
    {ok, UserInfo}.

  -spec sign_in(types:auth_type(), map())-&amp;gt;
    {ok, map()}
    | {erorr, invalid_auth_info}.
  sign_in(Type, AuthData)-&amp;gt;
    {ok, AuthModule} = auth_plugin_utils:type_to_auth_module(Type),
    case
      AuthModule:get(Type, AuthData)
    of
      {ok, UserIdx}-&amp;gt;
        {ok, UserInfo} = model_user:get_by_user_idx(UserIdx),
        {ok, UserInfo};
      {error, _} = Err-&amp;gt;
        Err
    end.
  
  -spec add_auth(pos_integer(), types:auth_type(), map())-&amp;gt;
    ok
    | {error, already_exist_auth_for_email}
    | {error, already_use_email}.
  add_auth(UserIdx, Type, AuthData)-&amp;gt;
    {ok, UserInfo} = model_user:get_by_user_idx(UesrIdx),
    {ok, AuthModule} = auth_plugin_utils:type_to_auth_module(Type),

    case
      AuthModule:new(UserInfo, AuthData)
    of
      {ok, _} -&amp;gt;
        ok;
      {error, _} = Err-&amp;gt;
        Err
    end.

    -spec withdraw(pos_integer()) -&amp;gt; ok.
    withdraw(UserIdx)-&amp;gt;
      {ok, UserInfo} = model_user:get_by_user_idx(UesrIdx),
        [
          AuthModule:remove(UserInfo)
          || AuthModule &amp;lt;- auth_plugin:get_all_auth_modules()],
      model_user:delete_by_user_idx(UserIdx),
      ok.

  %%%
  %%% Internal Function
  %%%

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;auth_plugin_for_emailerl&quot;&gt;auth_plugin_for_email.erl&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Erlang&quot;&gt;
  -behavior(auth_plugin).
  -export_all().
  
  -spec new(UserInfo :: map(), AuthData :: map()) -&amp;gt; 
    {ok, map()}
    | {error, already_exist_auth_for_email}
    | {error, already_use_email}.
  new(#{uesr_idx := UesrIdx} = UserInfo, #{email := Email, password := Password} = _AuthData)-&amp;gt;
    IsAlreadyHasAuth = 
      case
        model_auth_for_email:get_by_user_idx(UserIdx)
      of
        {ok, _}-&amp;gt;
          true;
        {error, _}-&amp;gt;
          false
      end,
    
    IsAlreadyUseEmail = 
      case
        model_auth_for_email:get_by_email(Email)
      of
        {ok, _}-&amp;gt;
          true;
        {error, _}-&amp;gt;
          false
      end,
      
    case
      {
        IsAlreadyHasAuth
        , IsAlreadyUseEmail
      }
    of
      {true, _} -&amp;gt;
        {error, already_exist_auth_for_email};
      {_, true} -&amp;gt;
        {error, already_use_email};
      {false, false} -&amp;gt;
        % 패스워드 암호화 과정 코드가 포함되어야 하지만, 여기에는 포함하지 않음.
        model_auth_for_email:insert(UserIdx, Email, Password)
    end.

  -spec get(AuthData :: map()) -&amp;gt; 
    {ok, pos_integer()}
    | {error, invalid_auth_info}.
  get(#{email := Email, password := Password} = _AuthData) -&amp;gt;
    case
      model_auth_for_email:get_by_email(Email)
    of
      {ok, AuthInfo} -&amp;gt;
        case
          maps:get(password, AuthInfo)
        of
          Password -&amp;gt; 
            {ok, maps:get(user_idx, AuthInfo)};
          _ -&amp;gt;
            {error, invalid_auth_info}
        end;
      {error, _} -&amp;gt;
        {error, invalid_auth_info}
    end.

  -spec remove(UserInfo :: map()) -&amp;gt; 
    {ok, any()}.
  remove(#{user_idx := UserIdx} = _UserInfo) -&amp;gt;
    model_auth_for_email:remove_by_user_idx(UserIdx).
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;auth_plugin_utilserl&quot;&gt;auth_plugin_utils.erl&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Erlang&quot;&gt;  -export_all().

  type_to_auth_module(email)-&amp;gt;
    {ok, auth_plugin:auth_plugin_for_email()};
  type_to_auth_module(Any)-&amp;gt;
    io:format(&quot;{[ [~p:~p] invalid auth module! ~p ]} ~n&quot;, [?MODULE, ?FUNCTION_NAME, Any]),
    {error, invalid_auth_module}.

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;auth_pluginerl&quot;&gt;auth_plugin.erl&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Erlang&quot;&gt;  -export_all().

  auth_plugin_for_email()-&amp;gt;
    ?FUNCTION_NAME().

  get_all_auth_modules()-&amp;gt;
    [FunctionName || {FunctioName, _Arity}&amp;lt;- module_info(exports), FunctionName =/= module_info, FunctionName =/= get_all_auth_modules].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;behavior는 Java로 치면 Interface같은 역할을 하는데, Erlang에서는 강제성을 띄지 않는다.&lt;br /&gt;
위와 같은 방식을 사용하면, 새로운 로그인/회원가입 방법이 추가되면 아래 순서대로 진행하면 된다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;로그인/회원가입 방법에 맞는 테이블 추가&lt;/li&gt;
  &lt;li&gt;로그인/회원가입 방법에 맞는 plugin 파일을 추가 ( ex : auth_plugin_for_kakao)&lt;/li&gt;
  &lt;li&gt;auth_plugin.erl 파일로 가서 해당 모듈명에 해당하는 함수를 추가시킨다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth_plugin_utils.erl&lt;/code&gt;파일에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fun type_to_auth_module/1&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kakao&lt;/code&gt;에 해당되는 패턴매칭을 추가시켜준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;만약, 특정 방법으로 추가적인 회원가입/로그인을 막게 되면, 해당 plugin 내부에서 new/get function의 return으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{error, not_suppert}&lt;/code&gt; 정도만 주면 될것이라 생각된다.&lt;/p&gt;

&lt;p&gt;실제, 해당 방법이 적용된 프로젝트는 서버는 TypeScript + Express + TypeORM를 사용하였고, 클라이언트는 Flutter를 통해 작성하였다.&lt;br /&gt;
개인적으로 재밌었는데, 서로 바빠지게 되면서, 추가적인 하지 못하게 되어 안타까운 토이 프로젝트였다.&lt;br /&gt;
해당 코드는 추후, 개인 Github를 통해서 올릴 예정이다.&lt;/p&gt;</content><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><category term="Thinking" /><summary type="html">하나의 유저 계정에 여러 로그인 방법 추가 설계 고민</summary></entry><entry><title type="html">Twinny Helper 앱 제작기</title><link href="https://jihwankim.github.io/flutter/Twinny-Helper-%ED%9B%84%EA%B8%B0/" rel="alternate" type="text/html" title="Twinny Helper 앱 제작기" /><published>2021-04-10T00:00:00+09:00</published><updated>2021-04-10T22:06:00+09:00</updated><id>https://jihwankim.github.io/flutter/Twinny-Helper-%ED%9B%84%EA%B8%B0</id><content type="html" xml:base="https://jihwankim.github.io/flutter/Twinny-Helper-%ED%9B%84%EA%B8%B0/">&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;사내 비즈박스 도입에 따른, TwinnyHelper 앱 제작기&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;총 개발 소요시간 : 약 20시간&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;올해 초, 사내 그룹웨어가 도입되었다.&lt;br /&gt;
도입된 그룹웨어는 비즈박스고, 해당 그룹웨어를 통해서 출퇴근기록, 휴가신청, 회의실예약 등이 가능하다.&lt;/p&gt;

&lt;p&gt;이전에, slack을 이용해서, 출근 기록을 기록하고, 해당 기록을 기반으로 회사 식대를 계산하는 Bot을 만들어서 사용했었는데, 해당 비즈박스의 API들을 사용하여, Bot의 기능을 대체할 수 있겠다고 생각했다.&lt;br /&gt;
해당 그룹웨어에서 자체 제작된 앱이 있으나, 출퇴근기록조회, 휴가신청같은 기능이 앱에서 동작하지 않아서 따로 제작하기로 마음먹었다.&lt;/p&gt;

&lt;p&gt;앱 제작에 사용된 프레임워크는 구글에서 만든 Flutter이다.&lt;br /&gt;
처음 접했을 때는 1.0이 막 런칭되었을 떄부터 조금씩 건드려보고 있는데, UI만드는 부분이 너무 직관적이고, 레고를 조립한다는 느낌을 받았어서 개인적으로 앱 만들기가 편하다고 생각하는 프레임워크다.&lt;/p&gt;

&lt;p&gt;상태관리는 Provider를 사용했다.&lt;br /&gt;
해당 라이브러리는 이전에 여러가지 앱을 만들때부터 사용해봤는데, 사용방법 자체도 간단하고 복잡하지 않아 개인적으로 만족스럽게 사용중이다.&lt;br /&gt;
저장소는 SharedPreference를 사용했고, 유저의 계정 id/password 를 암호화해서 저장하였다.&lt;/p&gt;

&lt;p&gt;일단 비즈박스에 공개된 API 문서부터 찾아보았는데, 해당 문서를 찾지 못했다.&lt;br /&gt;
따라서, 크롬 개발자 도구를 이용해서, 네트워크 통신 내용을 보며, API 정보를 하나 하나 찾아갔다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;로그인&quot;&gt;로그인&lt;/h1&gt;
&lt;p&gt;비즈박스 그룹웨어에서는 클라이언트(웹) 측에서 계정아이디와 비밀번호를 암호화해서 보낸다.&lt;br /&gt;
해당 부분에 대해서 앱 내에서도 따라 구현하였다.&lt;/p&gt;

&lt;p&gt;로그인시, 쿠키발급을 위한 API와, 실제 추가적인 몇가지 권한을 부여하는 API가 따로 존재했다.&lt;br /&gt;
즉, 로그인 API 요청 -&amp;gt; 쿠키발급 -&amp;gt; 권한부여 서버(Spring)로 Redirect -&amp;gt; 메인 페이지 이동 순서로 로그인이 진행되었다.&lt;br /&gt;
만약, 쿠키는 발급받았는데, Spring 서버로 Redirect시키지 않으면 일부 기능이 정상동작하지 않는다.&lt;br /&gt;
(그중, 경험했던 정상동작하지 않는 부분은 자원예약에서 참여자를 지정할 수 있는데, 해당 목록을 불러오지 못하는 부분이 있었다.)&lt;/p&gt;

&lt;h1 id=&quot;근무기록&quot;&gt;근무기록&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;해당 기능은 비즈박스 어플리케이션에서 조회할 수 없음&lt;/strong&gt;&lt;br /&gt;
근무기록을 가져오는 작업은 금방 끝났다. 데이터와 요청 자체가 간단했기 때문이다.&lt;br /&gt;
하지만, 휴가를 쓰게 되면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;휴가&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;출근여부 정상&lt;/code&gt; 두개가 동일한 날에 존재하는 경우가 있다는 것을 추후 유지보수 단계에서 알게 된 부분이 있었는데, 해당 부분은 여유될때 추가적으로 개선해야될 부분이다.&lt;/p&gt;

&lt;h1 id=&quot;식대계산&quot;&gt;식대계산&lt;/h1&gt;
&lt;p&gt;식대는 사내 규칙으로만 존재하며, 비즈박스 앱에서는 제공하지 않는 기능이다.&lt;br /&gt;
식대는 근무기록을 기반으로, 당일 출근하면 7000원. 근무시간이 11시간을 넘어가면 14000원이 되는 방식이다.&lt;br /&gt;
앱 내에서는 계산을 하고 당월 첫째날부터 당일까지 사용 가능한 총 식대를 계산하여 보여준다.&lt;/p&gt;

&lt;h1 id=&quot;휴가-기안&quot;&gt;휴가 기안&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;해당 기능은 비즈박스 어플리케이션에서 사용할 수 없음&lt;/strong&gt;&lt;br /&gt;
휴가 기안에 대한 기능을 앱에 구현할 때 생각보다 시간이 오래 걸렸던 걸로 기억한다.&lt;br /&gt;
그 이유는 여러개의 휴가 목록. 휴가 공유 캘린더 따로 존재. 휴가 기안시 페이지로 넘어갈 때, 휴가 목록에 대한 HTML로 전달하는 부분, 휴가 선택시, 공휴일 혹은 주말여부 자동 제외 등이 있었다.
그리고 휴가를 쓸 때, 결제자를 설정하는데, 해당 설정란을 가져와서 순서를 어떻게 하느냐도 문제였었다.&lt;br /&gt;
어떻게 꾸역꾸역 작업해서 결국 앱 내에 휴가 기안 기능은 포함되었고, 개인적으로 웹에 접속해서 신청하는 것보다 훨씬 편하다고 생각한다.&lt;/p&gt;

&lt;h1 id=&quot;자원-달력&quot;&gt;자원 달력&lt;/h1&gt;
&lt;p&gt;자원 달력은 비즈박스 앱에도 존재하는 기능인데, 회의실/장비같은 자원을 예약하고, 예약 목록을 조회할 수 있는 기능이다.&lt;br /&gt;
해당 부분에 대해서는 비즈박스 앱과 거의 동일하게 옮겨왔는데, 자원에 따라서 따로 당일 예약 여부를 볼 수 있다는 차이점이 존재한다.&lt;/p&gt;

&lt;h1 id=&quot;업데이트-이력-관리-및-배포&quot;&gt;업데이트 이력 관리 및 배포&lt;/h1&gt;
&lt;p&gt;업데이트 이력 관리는 github에 올려둔 파일을 조회하여 이력을 관리하도록 하였다.&lt;br /&gt;
해당 파일에는 버전/업데이트 로그가 존재한다.&lt;br /&gt;
그리고 배포는 사내 앱배포 어플리케이션인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트위니 앱센터&lt;/code&gt;와 회사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Confluence&lt;/code&gt;를 이용하여 배포하였다.&lt;/p&gt;

&lt;h1 id=&quot;디자인&quot;&gt;디자인&lt;/h1&gt;
&lt;p&gt;앱 디자인은 처음에는 무척 투박했으나, 친하게 지내는 회사 디자이너분께서 근무기록+식대계산을 하는 화면에 대해서만 어느정도 디자인을 해주셨다.&lt;br /&gt;
디자인 당시, 나는 근무기록 + 식대계산을 한 화면에 넣고 싶어했고, 디자이너분꼐서는 두개의 성격이 달라서, 같은 페이지에 있으면 문제가 될 수 있다고 이야기 해주셨었는데, 이야기 끝에 타협하여 지금의 형태가 되었다. ( 솔직히 거의 밀어붙이기만 했었다… )&lt;/p&gt;

&lt;p&gt;실제로, 4월의 경우, 시작이 되는 1일이 월요일이 아니어서 금주의 출근기록을 조회 + 평균근무시간을 보여주는 디자인과 식대를 계산한 디자인이 매치되지 않는 부분이 있다고 느꼈었다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;열심히 만들었고, AOS/IOS/DESKTOP으로 Deploy하여 배포해보았는데, 개인적으로 재밌었고, 사람들이 잘쓰고있다고 너무 좋다고 이야기해주는 것을 보니, 보람찼다.&lt;br /&gt;
그리고 처음으로 디자이너가 준 디자인을 보고 맞춰가면서 작업해봤는데, 어려울거라고는 생각했지만, 생각보다 더 어려웠었다. 하지만, 처음 해보니, 재미도 있었다.&lt;br /&gt;
앱을 만들면서 나는 정리가 잘 안된다를 다시 한 번 느꼈고, 아직도 많이 부족하구나를 다시 한번 느꼈다. 더 정진해야겠다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;디자인 도움을 주신 디자이너분께 다시한번 감사합니다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;앱은 추후, 코드를 조금 더 정리한 뒤에 개인 git에 공개할 예정이다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;(휴가 기안시, 대상이되는 캘린더를 임의로 변경할 수 있게 수정하고, 타회사와 맞지 않는 식대계산 부분은 제외할 예정)&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;인앱-사진&quot;&gt;인앱 사진&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;아래에서 자원 예약시, 참여자는 캡처 당시 모바일 환경에서 보이질 않아서 제외함.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;출퇴근기록 / 식대 / 주평균출근시간
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-1.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가신청 목록
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-2.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가신청 화면
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-3.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;결제라인 설정(조회)
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-4.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가신청 화면 (결제라인 설정이후)
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-5.png&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가 선택 화면
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-6.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가 종류 목록
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-7.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가 선택 화면 ( 종류선택 + 날짜지정 이후 )
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-8.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가 신청화면 ( 상신라인 설정 및 휴가 목록 선택 이후 )
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-9.png&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자원 달력
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-10.png&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자원 달력 예약 디테일
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-11.png&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자원 달력 자원 종류 필터링
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-12.png&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자원 예약
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-13.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자원 예약 ( 자원 목록 )
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-14.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설정
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-15.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;버전정보 및 업데이트 로그
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-16.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><category term="Flutter" /><category term="Flutter" /><summary type="html">사내 비즈박스 도입에 따른, TwinnyHelper 앱 제작기</summary></entry><entry><title type="html">푸시 스로틀링</title><link href="https://jihwankim.github.io/moigo/%ED%91%B8%EC%8B%9C-%EC%8A%A4%EB%A1%9C%ED%8B%80%EB%A7%81/" rel="alternate" type="text/html" title="푸시 스로틀링" /><published>2021-04-09T00:00:00+09:00</published><updated>2021-04-09T22:06:00+09:00</updated><id>https://jihwankim.github.io/moigo/%ED%91%B8%EC%8B%9C-%EC%8A%A4%EB%A1%9C%ED%8B%80%EB%A7%81</id><content type="html" xml:base="https://jihwankim.github.io/moigo/%ED%91%B8%EC%8B%9C-%EC%8A%A4%EB%A1%9C%ED%8B%80%EB%A7%81/">&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;모이고 푸시 스로틀링을 통한 TOPIC_RATE_EXCEEDED 에러 방지&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://firebase.google.com/docs/cloud-messaging/concept-options#device_throttling&quot;&gt;단일 기기에 대한 최대 메시지 속도&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://firebase.google.com/docs/cloud-messaging/send-message?hl=ko#admin&quot;&gt;FCM 에러 목록&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;모이고 기능 개발도중 FCM에 TOPIC RATE EXCEEDED 에러가 발생했다.&lt;/p&gt;

&lt;p&gt;해당 에러의 발생 사유는 아래와 같다.&lt;br /&gt;
&lt;strong&gt;특정 주제의 구독자에게 전달되는 메시지 비율이 너무 높습니다. 이 주제로 보내는 메시지 수를 줄이세요. 바로 다시 보내도록 시도해서는 안 됩니다&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;일단, 단일 기기에 대한 최대 메세지 속도 제한을 보고 접근했다.&lt;/p&gt;

&lt;p&gt;문서 상에서 FCM의 클라이언트 수신 가능한 최대 개수가 분당 240개. 시간당 5000개까지 제한하고 있다.&lt;br /&gt;
분당 240개를 잡고 계산했을 때, 0.25초당 1개의 푸시만 클라이언트에 전송되어야 한다.&lt;br /&gt;
물론, 최대로 잡았을 떄 저렇다는 거지, 실제로는 더 적게 보내야 한다.&lt;/p&gt;

&lt;p&gt;당장 보내는 메세지의 수를 많이 줄이는 것은 어렵다고 판단했다.&lt;br /&gt;
따라서, 최근에 해당 부분에 대해서 작업하여, 0.25초마다 한번씩만 푸시를 하도록 하였다.&lt;br /&gt;
여러개의 푸시가 한번에 몰려도 토픽당 1초에 최대 4번까지만 전송한다는 이야기다.&lt;br /&gt;
코드 상에서는 각 토픽마다 gen_server를 global로 띄운후에, 요청 function 을 호출하면, 띄워진 토픽에 해당하는 gen_server로 푸시요청이 넘겨지고, 매 0.25초 마다 한번씩 해당 푸시를 전송하도록 하였다.&lt;/p&gt;

&lt;p&gt;이후, 해당에러는 발생하지 않게 되었다.&lt;/p&gt;

&lt;p&gt;채팅을 제공하고, 여러가지 동작에 대해서 클라이언트간 싱크를 지원하기 위해 각 동작마다 FCM을 전송하고 있기 때문에, 위 방법은 임시조치일 뿐, 해결방법이 되지는 못한다.&lt;br /&gt;
따라서, 지금 생각해본 해결방법은 포그라운드일 경우, WebSocket을 통해 데이터를 받고, 백그라운드일 경우, FCM Notification만 클라이언트에 전송하는 방법이다.&lt;br /&gt;
해당 부분에 대해 개선을 하게 되면, 추후 포스팅을 통해, 문제가 되었던 점과 어떤것을 고민했는지 남길 예정이다.&lt;/p&gt;</content><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><category term="MoiGo" /><summary type="html">모이고 푸시 스로틀링을 통한 TOPIC_RATE_EXCEEDED 에러 방지</summary></entry><entry><title type="html">푸시 시스템 개선</title><link href="https://jihwankim.github.io/moigo/%EB%AA%A8%EC%9D%B4%EA%B3%A0-%ED%91%B8%EC%8B%9C-%EA%B0%9C%EC%84%A0/" rel="alternate" type="text/html" title="푸시 시스템 개선" /><published>2021-04-06T00:00:00+09:00</published><updated>2021-04-06T22:06:00+09:00</updated><id>https://jihwankim.github.io/moigo/%EB%AA%A8%EC%9D%B4%EA%B3%A0-%ED%91%B8%EC%8B%9C-%EA%B0%9C%EC%84%A0</id><content type="html" xml:base="https://jihwankim.github.io/moigo/%EB%AA%A8%EC%9D%B4%EA%B3%A0-%ED%91%B8%EC%8B%9C-%EA%B0%9C%EC%84%A0/">&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;모이고 서버 푸시 개선에 대한 포스팅&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;작성-이유&quot;&gt;작성 이유&lt;/h1&gt;

&lt;p&gt;2019년 트위니에서 회사 시무식에서 이벤트로 모이고 그룹방에서 퀴즈에 대해 정답을 입력하는 이벤트를 진행했다.&lt;br /&gt;
해당 이벤트를 진행하던 도중 모이고 서버가 터지는 일이 발생했다. 심지어 모이고 서버는 Erlang으로 작성되어있다.&lt;br /&gt;
왜 이런 일이 발생한건지, 원인은 무엇이고 어떻게 이것을 개선했는지에 대한 글이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;서버가-왜-터졌는가&quot;&gt;서버가 왜 터졌는가&lt;/h1&gt;

&lt;p&gt;서버가 터졌던 이유중 하나로는 서버가 1대만 떠있었기 때문이다.&lt;br /&gt;
서버가 1대만 떠있던 이유는 당시 모이고 DAU가 매우 적었기 때문에, 비용 절감을 위해 2대 -&amp;gt; 1대로 서버의 수를 줄여놨었다.&lt;br /&gt;
비용절감을 위해서라지만, 1대라면, 해당 서버가 죽어버리면, 바로 장애가 일어나게 된다. 애초에 2~3대를 기본적으로 운용했어야 했는데, 해당 부분은 우리팀의 실수였다.&lt;br /&gt;
이후, 서버는 상시 2대를 기본 운용하도록 변경하였다.&lt;br /&gt;
만약, 2대가 있었다면, 요청분산이 어느정도 될 테니, 서버가 죽진 않았을거라 생각된다.&lt;/p&gt;

&lt;p&gt;서버가 터졌던 가장 큰 이유는 모이고 서버의 푸시 전송 방식이 효율적이지 않아서였다.&lt;br /&gt;
당시 클라이언트별로 데이터 푸시를 따로 보내고, 알람도 따로 보냈다.&lt;br /&gt;
채팅전송시 한명의 유저에게 보내는 푸시는 AOS의 채팅데이터 푸시. IOS 채팅 데이터 푸시. IOS 노티푸시가 있다. (클라이언트 타입별로 따로 보내고 있었다.)&lt;/p&gt;

&lt;p&gt;만약, 그룹으로 채팅을 보낸다면, 개개인에게 푸시를 각자 전송했었고, 만약, 10명이 있는 방이라면 채팅 1개당 전송되는 푸시의 개수는 30개가 된다.&lt;br /&gt;
추가적으로 채팅을 읽었을때도 푸시가 있어서 이런걸 합하면, 50~60명의 유저가 채팅방에 있을 때, 일시에 채팅전송을 시작한다면, 어마어마한 양의 FCM 전송요청이 생긴다.&lt;br /&gt;
간단하게 계산해보면, 채팅 하나당 전송되는 푸시 요청 횟수는 150회가 되는데, 연속적으로 채팅을 전송하게된다면? 생각만해도 끔찍하다.&lt;/p&gt;

&lt;p&gt;요청이 있는것만으로 서버가 죽은 이유는 Erlang에 동시에 떠있는 프로세스 개수가 많아지면서 메모리를 너무 많이 잡아먹어서였다.&lt;br /&gt;
만약, 채팅전송을 한다면, 푸시 자체는 비동기로 전송하기 때문에, 비동기 푸시를 위해 프로세스가 하나 더 뜬다. 이후, 보내야하는 유저별로 데이터 싱크를 위한 저장소에 추가적으로 데이터를 저장하게 된다. 해당 동작도 비동기로 동작한다. 즉 여기서 프로세스가 유저수만큼 뜨게 된다.&lt;br /&gt;
이후, lhttpc library 자체적으로 프로세스를 띄워서 요청했던 것으로 기억하는데, 해당 요청수만큼 다시 프로세스가 뜨고, 추가적으로 몇개의 프로세스가 더 뜨는 것을 확인했었다.&lt;/p&gt;

&lt;p&gt;실제로, 개발서버에 테스트를 해봤었을때, 특정 프로세스가 많이 떠있던것을 확인했는데, ssl 관련 프로세스였던 것으로 기억한다.&lt;/p&gt;

&lt;p&gt;위 과정을 거쳐 프로세스가 비정상적으로 많이 떠있게 되며, 메모리가 가득차게 되어 서버가 죽어버렸다.&lt;/p&gt;

&lt;p&gt;그렇다면 해당 푸시를 어떻게 최적화를 시켜야할까? 라는 고민은 이전부터 있었다.&lt;br /&gt;
해당 현상에 대해 어느정도 예상했었고, 당시 사수형과 이야기해서 해당 부분에 대해 나중에 개선하자고 이야기가 되어있었다.&lt;/p&gt;

&lt;p&gt;시무식 당시에 이러한 이유로 서버가 죽어버리자, 푸시 전송방식을 개선하였다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;푸시-방식-개선-여정&quot;&gt;푸시 방식 개선 여정&lt;/h1&gt;

&lt;p&gt;푸시 개선은 결과적으로 보면 아래와 같이 바뀌었다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;개선이전&lt;/th&gt;
      &lt;th&gt;개선이후&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;토픽&lt;/td&gt;
      &lt;td&gt;유저토픽&lt;/td&gt;
      &lt;td&gt;유저토픽 + 그룹토픽 (그룹단위 토픽)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;푸시방식&lt;/td&gt;
      &lt;td&gt;모든 유저에게 각자의 토픽에 대해 푸시&lt;/td&gt;
      &lt;td&gt;유저 대상으로는 이전과 동일한 방식으로 푸시. 하지만, 그룹이 대상이라면, 그룹 토픽으로 푸시&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;개선 이전 방법에서 개선 이후 방식으로 곧바로 넘어가게 되면 업데이트되지 않은 클라이언트들이 정상동작하지 않게 될것이고, 그렇다고 그대로 두면 서버가 또 터지는 일이 발생할테니, 양쪽을 모두 사용할 수 있는 방식으로 개선되었다.&lt;/p&gt;

&lt;p&gt;일단, 푸시 데이터 종류에 따라, 우선순위를 지정을 하고, 우선순위에 따라 높은 우선순위의 아이템부터 유저에게 푸시하였다.&lt;br /&gt;
각 우선순위에 따라, AWS SQS에 push하고, 우선순위가 높은 큐에서부터 pull을 하여 우선 푸시하는 방법을 사용하였다.&lt;br /&gt;
우선순위가 높은 것들에는 채팅, 그룹원변경 등이 었었고, 낮은 운선순위의 것들은 채팅읽음 동기화 푸시 등이 있다.&lt;/p&gt;

&lt;p&gt;그리고 여러개의 토픽에 대해서 묶어서 한번에 푸시할 수 있도록 FCM 요청도 개선되었다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ( ex condition : ~~ in topics || ~~ in topics)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 작업을 하고 난 이후에는 동일한 이유로 서버가 터지는 일은 없었다.&lt;/p&gt;

&lt;p&gt;이후, 클라이언트가 업데이트를 어느정도 하였고, 개선버전 푸시 시스템으로 넘어가도 문제가 없는 시기가 되었다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;푸시-개선-적용&quot;&gt;푸시 개선 적용&lt;/h2&gt;

&lt;p&gt;실제로 개선버전 푸시 방식을 적용하기 전, 클라이언트에 알람을 보내는 부분에서 문제가 발생하였다.&lt;br /&gt;
IOS의 경우, 백그라운드 동작을 할 수가 없어서 알람을 서버에서 직접 쏘는데, 유저 설정에 따라 알람을 받지 않기도 하고, 친구의 이름 설정에 따라, 알람이 다르게 와야 한다.&lt;br /&gt;
하지만, 코드 상에서는 대상 토픽을 대상으로 알람을 쏘고 있었기 때문에, 알람이 원하던 것과 다르게 전송되고 있었다.&lt;br /&gt;
따라서, 유저별로 알람을 따로 보내게끔 추가로 개선해야 했었다.&lt;/p&gt;

&lt;p&gt;해당 부분에 대해 어떻게 해결할까 고민하며 서칭하던 중에 FCM 기능중 Multicast기능이 있고, 해당 기능이 알람을 보낼때 아주 적합하다고 생각했다.&lt;/p&gt;

&lt;p&gt;그룹 알람의 경우, 알람을 꺼놓지 않은 유저들에 대한 정보만 가져와서 해당 유저들에게만 Notification을 푸시하도록 수정하였다.&lt;br /&gt;
개인 대상으로 전송해야 할 때는 차이가 없었지만, 그룹에서 여러명의 유저에게 한번에 묶어서 보낸다는 것은 대단히 큰 이점이라고 생각한다.&lt;br /&gt;
Notification에는 Multicast기능을 이용하여 푸시하도록 개선하였다.&lt;/p&gt;

&lt;p&gt;또, 각 클라이언트 타입별로 메세지를 따로 보내고 있었는데, 현재 모이고에서 사용되고 있는 메세지 body는 IOS/ANDROID를 따로 보낼 필요가 없어서 하나로 통합하여 보내도록 개선하였다.&lt;/p&gt;

&lt;p&gt;개선이 모두 이루어 지고 나서, 너무나도 느렸던 모이고의 푸시 속도는 놀라울 정도로 개선되었다.&lt;/p&gt;

&lt;p&gt;많은 부분이 좋아지고 있지만, 갈길은 여전히 멀다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;추가적으로 해당 작업도중 HTTP v1이 출시된 것을 알고 버전을 올리려고 했으나, 버그가 발생하여 올리지 못했다. 해당 부분에 대해서는 추후에 따로 포스팅해볼 예정이다.&lt;/p&gt;</content><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><category term="MoiGo" /><summary type="html">모이고 서버 푸시 개선에 대한 포스팅</summary></entry></feed>